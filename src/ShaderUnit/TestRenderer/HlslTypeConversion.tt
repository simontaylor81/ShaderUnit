<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;

namespace ShaderUnit.TestRenderer
{
	static class HlslTypeConversion
	{
		// Get the HLSL type that coresponds to a given CLR type.
		// Supports only certain known types.
		public static string ClrTypeToHlsl(Type type)
		{
			if (type == typeof(float))
			{
				return "float";
			}
			else if (type == typeof(int))
			{
				return "int";
			}
			else if (type == typeof(uint))
			{
				return "uint";
			}
<# foreach (var vectorType in NumericsVectorTypes())
{
#>
			else if (type == typeof(<#= vectorType.name #>))
			{
				return "float<#= vectorType.size #>";
			}
<#
}
#>
<# foreach (var vectorType in ShaderUnitVecTypes())
{
#>
			else if (type == typeof(<#= vectorType.name #>))
			{
				return "float<#= vectorType.size #>";
			}
<#
}
#>
			else if (type == typeof(System.Numerics.Matrix4x4))
			{
				// System.Numerics.Matrix4x4 is row-major in memory, so match that.
				return "row_major float4x4";
			}
<# foreach (var matrixType in ShaderUnitMatrixTypes())
{
#>
			else if (type == typeof(<#= matrixType.name #>))
			{
				// ShaderUnit.Maths.Matrix4x4 is also row-major in memory, so match that.
				return "row_major float<#= matrixType.sizeX #>x<#= matrixType.sizeY #>";
			}
<#
}
#>

			throw new ArgumentException($"Type cannot be converted to HLSL: {type.ToString()}", nameof(type));
		}

		// Get a HLSL type constructor literal for a given CLR object.
		// Supports only certain known types.
		public static string ClrValueToHlslLiteral(object value)
		{
			var type = value.GetType();
			if (type == typeof(float) || type == typeof(int) || type == typeof(uint))
			{
				// Scalars are easy.
				return value.ToString();
			}
<# foreach (var vectorType in NumericsVectorTypes())
{
#>
			else if (type == typeof(<#= vectorType.name #>))
			{
				var vec = (<#= vectorType.name #>)value;
				return $"float<#= vectorType.size #>(<#= VectorAccess(vectorType.size, true) #>)";
			}
<#
}
#>
<# foreach (var vectorType in ShaderUnitVecTypes())
{
#>
			else if (type == typeof(<#= vectorType.name #>))
			{
				var vec = (<#= vectorType.name #>)value;
				return $"float<#= vectorType.size #>(<#= VectorAccess(vectorType.size, false) #>)";
			}
<#
}
#>
			else if (type == typeof(System.Numerics.Matrix4x4))
			{
				var m = (System.Numerics.Matrix4x4)value;
				return $"float4x4({m.M11}, {m.M12}, {m.M13}, {m.M14}, {m.M21}, {m.M22}, {m.M23}, {m.M24}, {m.M31}, {m.M32}, {m.M33}, {m.M34}, {m.M41}, {m.M42}, {m.M43}, {m.M44})";
			}
<# foreach (var matrixType in ShaderUnitMatrixTypes())
{
#>
			else if (type == typeof(<#= matrixType.name #>))
			{
				var m = (<#= matrixType.name #>)value;
				return $"float<#= matrixType.sizeX #>x<#= matrixType.sizeY #>(<#= MatrixAccess(matrixType.sizeX, matrixType.sizeY) #>)";
			}
<#
}
#>

			throw new ArgumentException($"Value cannot be converted to HLSL: {value.ToString()}", nameof(value));
		}
	}
}

<#+

private struct VectorType
{
	public int size;
	public string name;
}

private struct MatrixType
{
	public int sizeX;
	public int sizeY;
	public string name;
}

private IEnumerable<VectorType> NumericsVectorTypes()
{
	return Enumerable.Range(2, 3).Select(i => new VectorType
	{
		size = i,
		name = "System.Numerics.Vector" + i.ToString(),
	});
}

private IEnumerable<VectorType> ShaderUnitVecTypes()
{
	return Enumerable.Range(2, 3).Select(i => new VectorType
	{
		size = i,
		name = string.Format("ShaderUnit.Maths.Vec{0}<float>", i),
	});
}

private IEnumerable<MatrixType> ShaderUnitMatrixTypes()
{
	return Enumerable.Range(1, 4).SelectMany(x => Enumerable.Range(1, 4), (x, y) => new MatrixType
	{
		sizeX = x,
		sizeY = y,
		name = string.Format("ShaderUnit.Maths.Matrix{0}x{1}<float>", x, y),
	});
}

private IEnumerable<string> VectorComponents(int size, bool uppercase)
{
	var result = (new[] { "x", "y", "z", "w" }).Take(size);
	if (uppercase)
	{
		result = result.Select(x => x.ToUpperInvariant());
	}
	return result;
}

private string VectorAccess(int size, bool uppercase)
{
	return string.Join(", ", VectorComponents(size, uppercase)
		.Select(component => "{vec." + component + "}"));
}

private IEnumerable<string> MatrixComponents(int sizeX, int sizeY)
{
	return Enumerable.Range(1, sizeX).SelectMany(x => Enumerable.Range(1, sizeY), (x, y) => string.Format("m{0}{1}", x, y));
}

private string MatrixAccess(int sizeX, int sizeY)
{
	return string.Join(", ", MatrixComponents(sizeX, sizeY)
		.Select(component => "{m." + component + "}"));
}

#>
